---
title: "AST как инструмент для автоматизации рутины"
date: 2019-02-19T17:45:38+03:00
draft: true
---

Всем привет! В этом посте я бы хотел рассказать о том, как с помощью небольшого количества строк кода можно автоматизировать рутинную работу по рефакторингу кода.

## Что же такое AST?

AST(abstract syntax tree) - абстрактное синтаксическое дерево - размеченное древовидное
представление кода, готовое для анализа и преобразования

## Чем полезно AST?

- На основе ast написаны различные инструменты анализа кода (eslint, prettier)
- С помощью AST можно автоматизировать рутинные действия с кодом, такие как форматирование,
переезд на новую версию какой-нибудь библиотеки или же попросту на другой стек

Конечно не всегда это возможно и не всегда это быстро, но гораздо интереснее чем переписывать
всё руками, согласитесь?

## Инструменты для работы с AST

@babel/parser - парсер кода, на вход берет строку кода, на выходе отдает AST

@babel/traverse - утилита используемая для прохода узлов AST

@babel/types - набор вспомогательных функций, можно использовать, например,
для создания узлов AST или для их валидации

@babel/generate - используется для преобразования ast обратно в кода

## Разберем работу с AST на примере
В момент перезда на Typescript появилась необходимость переехать с redux-actions, т.к. он не
имеет собственного тайпинга, а тот, который я нашел оказался не самым лучшим, поэтому логичным
решением было переехать на более приспособленный инструмент для работы с redux actions на TS

## Начнём
Для начала рассмотрим reducer, написанный с помощью redux-actions. Я решил не заморачиваться сильно и использовать давно проверенную схему: брать за основу TODO приложение

```javascript
import { handleActions } from 'redux-actions';

import * as actions from './actions';

const initialState = {
    todos: [],
};

export default handleActions({
    [actions.addTodo](state, { payload }) {
        return {
            ...state,
            todos: [...state.todos, payload],
        };
    },
    [actions.deleteTodo](state, { payload }) {
        return {
            ...state,
            todos: [...state.todos, payload],
        };
    },
}, initialState);
```

Чтобы получить аналогичный код для typesafe-actions нам нужно:

1. Заменить импорт
2. Создать тип для действий
3. Заменить вызов handleActions на обявление функции с логикой по обработке действий в switch/case

### Заменим импорт

Для совершения манипуляций над узлами ast мы будем пользоваться, упомянутым выше, модулем @babel/traverse, он принимает на вход ast и объект с методами называемыми "визиторы", визитор это метод, название которого должно соответствовать типу ноды которую мы хотим посетить, например в случае с заменой импорта мы должны назвать метод-визитор `ImportDeclaration`. Давайте перейдем непосредственно к коду нашего визитора.

```javascript
traverse(ast, {
    ImportDeclaration(path) {
        if (path.node.source.value === "redux-actions") { // определяем что это именно тот импорт, который нам нужно заменить
            path.replaceWith(
                types.importDeclaration(
                    [
                        types.importSpecifier(
                            types.identifier('getType'),
                            types.identifier('getType')
                        ),
                        types.importSpecifier(
                            types.identifier('ActionType'),
                            types.identifier('ActionType')
                        ),
                    ],
                    types.stringLiteral('typesafe-actions')
                )
            );
        }
    }
}
```
